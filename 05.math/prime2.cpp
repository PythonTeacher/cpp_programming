// 4. 에라토스테네스의 체
// 문제점) 어떤 수 N이 소수인지 알아내는데 걸리는 시간 복잡도는 O(루트N)
// 1~1,000,000까지 모든 소수를 구하는데 걸리는 시간 복잡도는?
// 각 수에 대해 O(루트N)이 걸리고, 수 갯수만큼 곱해야 하므로 O(N루트N)이 걸림
// 1,000,000 * 1,000 = 1,000,000,000 = 10억 = 10초
// 너무 시간이 오래 걸린다 -> 다른 방법을 찾자!

// 에라토스테네스의 체
// 1. 2부터 N까지 모든 수를 써놓는다.
// 2. 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.
// 3. 그 수는 소수이다.
// 4. 이제 그 수의 배수를 모두 지운다.

#include <iostream>

using namespace std;

int main() {
    // 1~100까지의 소수 찾기
    int n = 100;
    int prime[n];       // 소수 저장
    int cnt = 0;        // 소수의 개수
    bool check[n+1] = {false,};    // true: 지워진 것 (소수가 아님), false: 지워지지 않음 (소수)

    for (int i=2; i<=n; i++) {
        if (check[i] == false) {  // 소수인 경우
            prime[cnt++] = i;
            // i*i가 정수의 범위를 벗어나는 경우에는 i*2로 하기
            for (int j = i*2; j<=n; j+=i) {
                check[j] = true;  // 지우기
            }
        }
    }

    for (int i=0; i<cnt; i++) {
        cout << prime[i] << ' ';
    }

    cout << "\n소수 갯수 => " << cnt << '\n';

    return 0;
}
